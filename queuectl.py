# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1llI1DlBuQm66m4pK6DAOsVFQY1VQnR-x

aaaaa
"""

#QueueCTL
code = r'''
import sqlite3, subprocess, time, argparse, sys, os
from datetime import datetime

DB_FILE = "queuectl.db"

def init_db():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS jobs(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        command TEXT NOT NULL,
        state TEXT NOT NULL,
        attempts INTEGER DEFAULT 0,
        max_retries INTEGER DEFAULT 3,
        created_at TEXT,
        updated_at TEXT
    )
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS dlq(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        command TEXT NOT NULL,
        reason TEXT,
        failed_at TEXT
    )
    """)
    conn.commit(); conn.close()

def now(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
def get_conn(): return sqlite3.connect(DB_FILE)

def enqueue(cmd):
    conn=get_conn(); c=conn.cursor()
    c.execute("INSERT INTO jobs(command,state,attempts,max_retries,created_at,updated_at)"
              " VALUES(?, 'pending',0,3,?,?)",(cmd,now(),now()))
    conn.commit(); conn.close()
    print(f"âœ… Added job: {cmd}")

def list_jobs():
    conn=get_conn(); c=conn.cursor()
    rows=c.execute("SELECT * FROM jobs").fetchall()
    if not rows: print("No jobs found.")
    else:
        for r in rows:
            print(f"[{r[0]}] {r[1]} | {r[2]} | {r[3]}/{r[4]}")
    conn.close()

def process_jobs():
    conn=get_conn(); c=conn.cursor()
    jobs=c.execute("SELECT * FROM jobs WHERE state IN ('pending','failed')").fetchall()
    if not jobs: print("No pending jobs."); conn.close(); return
    for job in jobs:
        jid,cmd,state,att,mr,_,_=job
        print(f"\nâ–¶ Running job {jid}: {cmd}")
        try:
            res=subprocess.run(cmd,shell=True,capture_output=True,text=True,timeout=10)
            if res.returncode==0:
                print(f"âœ… Job {jid} completed.")
                c.execute("UPDATE jobs SET state='completed',updated_at=? WHERE id=?",(now(),jid))
            else:
                raise Exception(res.stderr.strip() or "Error")
        except Exception as e:
            att+=1
            print(f"âš ï¸ Job {jid} failed: {e}")
            if att>=mr:
                print(f"ðŸ’€ Job {jid} â†’ DLQ")
                c.execute("DELETE FROM jobs WHERE id=?",(jid,))
                c.execute("INSERT INTO dlq(command,reason,failed_at) VALUES(?,?,?)",(cmd,str(e),now()))
            else:
                c.execute("UPDATE jobs SET state='failed',attempts=?,updated_at=? WHERE id=?",(att,now(),jid))
        conn.commit(); time.sleep(1)
    conn.close(); print("\nðŸŽ¯ All jobs processed.")

def show_status():
    conn=get_conn(); c=conn.cursor()
    print("\nðŸ“Š Job Summary:")
    for s in ["pending","completed","failed"]:
        c.execute("SELECT COUNT(*) FROM jobs WHERE state=?",(s,))
        print(f"{s:10}:{c.fetchone()[0]}")
    c.execute("SELECT COUNT(*) FROM dlq")
    print(f"dead(DLQ)  :{c.fetchone()[0]}")
    conn.close()

def show_dlq():
    conn=get_conn(); c=conn.cursor()
    rows=c.execute("SELECT * FROM dlq").fetchall()
    if not rows: print("DLQ empty.")
    else:
        print("\nðŸ’€ Dead Letter Queue:")
        for r in rows:
            print(f"[{r[0]}] {r[1]} | {r[2]} | {r[3]}")
    conn.close()

def main():
    init_db()
    argv=[a for a in sys.argv[1:] if not a.startswith('-f') and not a.endswith('.json')]
    parser=argparse.ArgumentParser()
    sub=parser.add_subparsers(dest="cmd")
    p=sub.add_parser("enqueue"); p.add_argument("job")
    sub.add_parser("worker"); sub.add_parser("status"); sub.add_parser("list"); sub.add_parser("dlq")
    if not argv:
        print("Usage:\n  enqueue <cmd>\n  worker\n  status\n  list\n  dlq"); return
    args=parser.parse_args(argv)
    if args.cmd=="enqueue": enqueue(args.job)
    elif args.cmd=="worker": process_jobs()
    elif args.cmd=="status": show_status()
    elif args.cmd=="list": list_jobs()
    elif args.cmd=="dlq": show_dlq()

if __name__=="__main__":
    main()
'''

with open("queuectl_final_fixed.py","w") as f:
    f.write(code)

print("âœ… Clean version saved as queuectl_final_fixed.py")
!ls

!python queuectl_final_fixed.py enqueue "echo Hello"
!python queuectl_final_fixed.py enqueue "sleep 1 && echo Done"
!python queuectl_final_fixed.py enqueue "invalid_command"

!python queuectl_final_fixed.py worker

!python queuectl_final_fixed.py status

!python queuectl_final_fixed.py dlq